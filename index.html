<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel de Control y Ruteo (Local)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Aviso de precarga para PapaParse -->
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.3.0/papaparse.min.js" as="script">
    
    <!-- 
    Chosen Palette: Minimalist Neutrals (Warm Grays)
    Application Structure Plan: 
    App rediseñada para funcionar 100% en el navegador SIN FIREBASE.
    1. Pestaña "Dashboard": Se pobla dinámicamente desde una variable JS local (`allOrders`) después de la sincronización.
    2. Pestaña "Planificador de Rutas": Implementa el flujo de trabajo en 3 pasos:
       - Paso 1: Sincronizar (Google Sheet) -> Limpia datos -> Almacena en la variable local `allOrders`. Dispara la actualización del Dashboard.
       - Paso 2: Generar Rutas -> Ejecuta una simulación de VRP (local) sobre `allOrders`.
       - Paso 3: Resultados -> Muestra los resultados (variables `generatedRoutes` y `unassignedOrders`) y activa un nuevo botón "Exportar Rutas (CSV)" para descargar los resultados.
    Esta estructura mantiene la UI pero reemplaza toda la lógica de base de datos por un estado local en JS.

    Visualization & Content Choices:
    - (Dashboard) Info: KPIs, Gráficos, Tabla.
      - Goal: Informar.
      - Viz/Method: Tarjetas, Gráficos Chart.js, Tabla HTML.
      - Interaction: Tooltips, Filtros.
      - Justification: Resumen operativo, ahora alimentado por `allOrders`.
    - (Planificador) Info: Sincronización Google Sheet.
      - Goal: Cargar datos.
      - Viz/Method: Input de URL, botón de sincronización.
      - Interaction: Clic de botón.
      - Justification: Carga los datos en la variable `allOrders`.
    - (Planificador) Info: Generador de Rutas (VRP Sim).
      - Goal: Procesar datos.
      - Viz/Method: Inputs (fecha, vehículos) y botón "Generar Rutas".
      - Interaction: Clic de botón.
      - Justification: Dispara la simulación local de VRP.
    - (Planificador) Info: Resultados y Exportación.
      - Goal: Informar y Entregar.
      - Viz/Method: Listas dinámicas y nuevo botón "Exportar Rutas (CSV)".
      - Interaction: Clic de botón (Exportar).
      - Justification: Cierra el ciclo entregando un archivo CSV con las rutas generadas.

    CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa; 
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 320px;
            max-height: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 360px;
            }
        }
        
        .table-container {
            width: 100%;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }
        
        thead th {
            position: sticky;
            top: 0;
            background-color: #f1f5f9;
            z-index: 10;
        }
        
        .tab-button {
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            color: #6b7280;
        }
        
        .tab-button.active {
            color: #4f46e5;
            border-bottom-color: #4f46e5;
        }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Plataforma de Ruteo y Análisis (Local)</h1>
            <p class="text-lg text-gray-600" id="report-date">Sincronice los datos para comenzar</p>
        </header>

        <!-- Navegación por Pestañas -->
        <nav class="border-b border-gray-300 mb-8">
            <div class="flex">
                <button id="tab-dashboard" class="tab-button active">Dashboard</button>
                <button id="tab-routing" class="tab-button">Planificador de Rutas</button>
            </div>
        </nav>

        <!-- Contenido Pestaña 1: Dashboard -->
        <div id="view-dashboard">
            <section id="kpis" class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Resumen del Día</h2>
                <p class="text-gray-600 mb-4">
                    Esta sección proporciona una vista de alto nivel de las métricas operativas clave del día. Use estas tarjetas para entender rápidamente el volumen y la escala de los pedidos gestionados.
                </p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-sm font-medium text-gray-500 uppercase">Total de Pedidos</h3>
                        <p class="text-3xl font-bold text-indigo-600" id="kpi-total-jobs">0</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-sm font-medium text-gray-500 uppercase">Tiendas Únicas</h3>
                        <p class="text-3xl font-bold text-indigo-600" id="kpi-total-stores">0</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-sm font-medium text-gray-500 uppercase">Clientes Únicos</h3>
                        <p class="text-3xl font-bold text-indigo-600" id="kpi-total-clients">0</p>
                    </div>
                </div>
            </section>

            <section id="visualizations" class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Visualizaciones de Distribución</h2>
                <p class="text-gray-600 mb-4">
                    Los siguientes gráficos desglosan la carga de trabajo del día. Analice estos gráficos para identificar horas pico, las tiendas con más volumen y las características predominantes de los pedidos.
                </p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-lg font-semibold text-center mb-4">Pedidos por Hora (Slot)</h3>
                        <div class="chart-container">
                            <canvas id="jobsByHourChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-lg font-semibold text-center mb-4">Pedidos por Tienda</h3>
                        <div class="chart-container">
                            <canvas id="jobsByStoreChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-lg font-semibold text-center mb-4">Métodos de Pago</h3>
                        <div class="chart-container">
                            <canvas id="jobsByPaymentChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-lg font-semibold text-center mb-4">Modelos Operativos</h3>
                        <div class="chart-container">
                            <canvas id="jobsByModelChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <section id="data-explorer">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Explorador de Pedidos</h2>
                <p class="text-gray-600 mb-4">
                    Utilice las herramientas de filtro a continuación para buscar pedidos específicos. Puede buscar por Job Number, Tienda o Cliente, o filtrar por un slot de tiempo específico para ver los detalles.
                </p>
                <div class="flex flex-col md:flex-row gap-4 mb-4 p-4 bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="flex-1">
                        <label for="search-input" class="block text-sm font-medium text-gray-700">Buscar</label>
                        <input type="text" id="search-input" placeholder="Buscar por Job Number, Tienda, Cliente..." class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    </div>
                    <div class="flex-1">
                        <label for="slot-filter" class="block text-sm font-medium text-gray-700">Filtrar por Slot</label>
                        <select id="slot-filter" class="mt-1 block w-full px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                            <option value="all">Todos los Slots</option>
                        </select>
                    </div>
                </div>
                <div class="table-container bg-white shadow-md">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-100">
                            <tr>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Job Number</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Tienda</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cliente</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Slot Inicio</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Slot Fin</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Método Pago</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Destino (Lat, Lon)</th>
                            </tr>
                        </thead>
                        <tbody id="jobs-table-body" class="bg-white divide-y divide-gray-200">
                        </tbody>
                    </table>
                </div>
                <p id="no-results" class="text-center text-gray-500 py-8 hidden">No se encontraron resultados para los filtros aplicados.</p>
            </section>
        </div>

        <!-- Contenido Pestaña 2: Planificador de Rutas -->
        <div id="view-routing" class="hidden">
            
            <!-- Paso 1: Importar desde Google Sheet -->
            <section id="importer" class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Paso 1: Sincronizar desde Google Sheet</h2>
                <p class="text-gray-600 mb-4">
                    Pega el enlace de tu Google Sheet publicado en la web (en formato CSV) para cargar los pedidos en la memoria del navegador.
                </p>
                <div class="p-6 bg-white rounded-lg shadow-md border border-gray-200">
                    <label for="gheet-url-input" class="block text-sm font-medium text-gray-700">URL de Google Sheet (publicado como CSV)</label>
                    <div class="flex flex-col md:flex-row gap-2 mt-1">
                        <input type="text" id="gheet-url-input" value="https://docs.google.com/spreadsheets/d/e/2PACX-1vS17Lju7CnNJpzS7zb2l237sZMyC-GVj33iROvKqIVo8SB7mlmh7BwpOb2e9TDQn8n9Sl0FGtc02bIj/pub?output=csv" class="flex-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <button id="sync-gheet-btn" class="px-5 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700 disabled:opacity-50" disabled>
                            Cargando...
                        </button>
                    </div>
                </div>
                <div id="import-status" class="mt-4">
                    <h4 class="font-semibold">Log de Sincronización:</h4>
                    <pre id="import-log" class="text-sm bg-gray-100 p-3 rounded-md h-32 overflow-y-auto">Esperando sincronización...</pre>
                </div>
            </section>

            <!-- Paso 2: Generar Rutas -->
            <section id="generator" class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Paso 2: Generar Rutas</h2>
                <p class="text-gray-600 mb-4">
                    Una vez sincronizados los pedidos, seleccione la fecha y el número de vehículos, luego ejecute la simulación.
                </p>
                <div class="p-6 bg-white rounded-lg shadow-md border border-gray-200 flex flex-col md:flex-row items-center gap-4">
                    <div>
                        <label for="vrp-date" class="block text-sm font-medium text-gray-700">Fecha de Ruta</label>
                        <input type="date" id="vrp-date" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="vrp-vehicles" class="block text-sm font-medium text-gray-700">Nº de Vehículos</label>
                        <input type="number" id="vrp-vehicles" value="4" min="1" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    </div>
                    <div class="mt-auto">
                        <button id="generate-routes-btn" class="flex items-center justify-center px-6 py-2 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700">
                            <span id="btn-text">Generar Rutas</span>
                            <div id="btn-loader" class="loader hidden ml-2"></div>
                        </button>
                    </div>
                </div>
            </section>

            <!-- Paso 3: Resultados -->
            <section id="results">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-gray-800">Paso 3: Resultados del Ruteo</h2>
                    <button id="export-routes-btn" class="px-5 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 disabled:opacity-50" disabled>
                        Exportar Rutas (CSV)
                    </button>
                </div>
                <p class="text-gray-600 mb-4">
                    Los resultados de la simulación local aparecerán aquí. Use el botón de exportar para descargar un CSV.
                </p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-lg font-semibold mb-4">Rutas Generadas</h3>
                        <div id="generated-routes-list" class="space-y-3 h-96 overflow-y-auto">
                            <p class="text-gray-500">Esperando resultados...</p>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                        <h3 class="text-lg font-semibold mb-4">Pedidos No Asignados</h3>
                        <div id="unassigned-jobs-list" class="space-y-2 h-96 overflow-y-auto">
                           <p class="text-gray-500">Esperando resultados...</p>
                        </div>
                    </div>
                </div>
            </section>

        </div>
    </div>

    <!-- Cargar PapaParse ANTES que el script del módulo que lo usa -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.3.0/papaparse.min.js"></script>

    <script type="module">
        // Estado local de la aplicación (en lugar de Firebase)
        let allOrders = [];
        let processedJobs = [];
        let generatedRoutes = [];
        let unassignedOrders = [];
        
        let charts = {};
        const chartColors = {
            blue: 'rgba(59, 130, 246, 0.7)', indigo: 'rgba(79, 70, 229, 0.7)',
            green: 'rgba(16, 185, 129, 0.7)', pink: 'rgba(236, 72, 153, 0.7)',
            yellow: 'rgba(245, 158, 11, 0.7)', purple: 'rgba(139, 92, 246, 0.7)',
            teal: 'rgba(20, 184, 166, 0.7)', red: 'rgba(239, 68, 68, 0.7)',
        };

        // --- NAVEGACIÓN ---
        
        // Hacer la función showView accesible globalmente
        window.showView = (viewId) => {
            document.getElementById('view-dashboard').classList.toggle('hidden', viewId !== 'dashboard');
            document.getElementById('view-routing').classList.toggle('hidden', viewId !== 'routing');
            
            document.getElementById('tab-dashboard').classList.toggle('active', viewId === 'dashboard');
            document.getElementById('tab-routing').classList.toggle('active', viewId === 'routing');
        };
        
        // Asignar eventos a los botones de pestañas
        document.getElementById('tab-dashboard').addEventListener('click', () => window.showView('dashboard'));
        document.getElementById('tab-routing').addEventListener('click', () => window.showView('routing'));

        // --- INICIALIZACIÓN ---

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                logToImportStatus(`Esperando sincronización...`);
                setupDashboardListeners();
                setupRoutingListeners();
                initializeImporter();
                document.getElementById('vrp-date').valueAsDate = new Date();
                document.getElementById('export-routes-btn').disabled = true;

            } catch (error) {
                console.error("Error inicializando la app:", error);
                logToImportStatus(`Error de inicialización: ${error.message}`, true);
            }
        });
        
        function initializeImporter() {
            if (typeof Papa !== 'undefined' && typeof Chart !== 'undefined') {
                const syncButton = document.getElementById('sync-gheet-btn');
                syncButton.disabled = false;
                syncButton.textContent = 'Sincronizar Pedidos';
                logToImportStatus("Librerías listas. Sincronice para comenzar.", false);
            } else {
                logToImportStatus("Cargando librerías de análisis...", false);
                setTimeout(initializeImporter, 200);
            }
        }
        
        // --- LISTENERS DE FILTROS (DASHBOARD) ---
        
        function setupDashboardListeners() {
            const searchInput = document.getElementById('search-input');
            const slotFilter = document.getElementById('slot-filter');
            
            const handleFilter = () => {
                const searchTerm = searchInput.value.toLowerCase();
                const selectedSlot = slotFilter.value;

                const filteredJobs = processedJobs.filter(job => {
                    const matchesSearch = 
                        (job.job_Number && job.job_Number.toLowerCase().includes(searchTerm)) ||
                        (job.tienda && job.tienda.toLowerCase().includes(searchTerm)) ||
                        (job.cliente_ID && job.cliente_ID.toLowerCase().includes(searchTerm));
                    
                    const matchesSlot = 
                        selectedSlot === 'all' || 
                        job.Slot_Hour === selectedSlot;

                    return matchesSearch && matchesSlot;
                });
                
                renderTable(filteredJobs);
            };

            searchInput.addEventListener('keyup', handleFilter);
            slotFilter.addEventListener('change', handleFilter);
        }

        // --- LÓGICA DE PROCESAMIENTO (DASHBOARD) ---

        function processAndRenderDashboard() {
            processedJobs = allOrders.map(job => ({
                ...job,
                Slot_Hour: formatHour(job.slot_Inicio),
                Slot_Start_Time: formatDateTime(job.slot_Inicio),
                Slot_End_Time: formatDateTime(job.slot_Fin)
            }));
            
            renderKPIs();
            renderCharts();
            populateSlotFilter();
            renderTable(processedJobs);
        }

        function cleanCoordinate(coord) {
            if (typeof coord === 'number') return coord;
            if (typeof coord !== 'string') return null;
            return parseFloat(coord.replace(',', '.'));
        }
        
        function parseDate(dateStr) {
            if (!dateStr) return null;
            let d = new Date(dateStr.replace(' ', 'T'));
            if (isNaN(d.getTime())) {
              const parts = dateStr.split(' ')[0].split('/');
              if (parts.length === 3 && parts[2].length === 4) {
                const timeStr = dateStr.split(' ')[1] || '00:00:00';
                d = new Date(`${parts[2]}-${parts[1]}-${parts[0]}T${timeStr}`);
              } else if (parts.length === 3 && parts[2].length === 2) {
                 const timeStr = dateStr.split(' ')[1] || '00:00:00';
                 d = new Date(`20${parts[2]}-${parts[1]}-${parts[0]}T${timeStr}`);
              }
            }
            return isNaN(d.getTime()) ? null : d;
        }

        function formatHour(date) {
            if (!date || typeof date.getHours !== 'function') return 'N/A';
            const hour = date.getHours().toString().padStart(2, '0');
            return `${hour}:00`;
        }
        
        function formatDateTime(date) {
             if (!date || typeof date.toLocaleTimeString !== 'function') return 'N/A';
             return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
        }

        function renderKPIs() {
            const totalJobs = processedJobs.length;
            const uniqueStores = new Set(processedJobs.map(j => j.tienda)).size;
            const uniqueClients = new Set(processedJobs.map(j => j.cliente_ID)).size;

            const kpiJobsEl = document.getElementById('kpi-total-jobs');
            const kpiStoresEl = document.getElementById('kpi-total-stores');
            const kpiClientsEl = document.getElementById('kpi-total-clients');
            const reportDateEl = document.getElementById('report-date');

            if (kpiJobsEl) kpiJobsEl.textContent = totalJobs;
            if (kpiStoresEl) kpiStoresEl.textContent = uniqueStores;
            if (kpiClientsEl) kpiClientsEl.textContent = uniqueClients;
            
            if (reportDateEl) {
                if (processedJobs.length > 0) {
                     const date = new Date(processedJobs[0].fecha_Formalizada || processedJobs[0].fecha_Creacion || Date.now());
                     reportDateEl.textContent = `Análisis de datos para: ${date.toLocaleDateString('es-ES', { day: '2-digit', month: 'long', year: 'numeric' })}`;
                } else {
                     reportDateEl.textContent = `No se encontraron datos`;
                }
            }
        }

        function aggregateData(key) {
            return processedJobs.reduce((acc, job) => {
                const value = job[key] || 'N/A';
                acc[value] = (acc[value] || 0) + 1;
                return acc;
            }, {});
        }

        function renderCharts() {
            const colorValues = Object.values(chartColors);
            
            Object.values(charts).forEach(chart => chart.destroy());

            if (processedJobs.length === 0) return;

            const jobsByHourData = aggregateData('Slot_Hour');
            const sortedHours = Object.keys(jobsByHourData).sort();
            charts.jobsByHour = new Chart(document.getElementById('jobsByHourChart'), {
                type: 'bar',
                data: {
                    labels: sortedHours,
                    datasets: [{ label: 'Nº de Pedidos', data: sortedHours.map(h => jobsByHourData[h]), backgroundColor: chartColors.blue }]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
            });

            const jobsByStoreData = aggregateData('tienda');
            charts.jobsByStore = new Chart(document.getElementById('jobsByStoreChart'), {
                type: 'doughnut',
                data: {
                    labels: Object.keys(jobsByStoreData),
                    datasets: [{ data: Object.values(jobsByStoreData), backgroundColor: colorValues }]
                },
                options: { responsive: true, maintainAspectRatio: false }
            });

            const jobsByPaymentData = aggregateData('metodo_Pago');
            charts.jobsByPayment = new Chart(document.getElementById('jobsByPaymentChart'), {
                type: 'pie',
                data: {
                    labels: Object.keys(jobsByPaymentData),
                    datasets: [{ data: Object.values(jobsByPaymentData), backgroundColor: [chartColors.green, chartColors.indigo, chartColors.yellow, chartColors.pink] }]
                },
                options: { responsive: true, maintainAspectRatio: false }
            });
            
            const jobsByModelData = aggregateData('modelo_Operativo');
            charts.jobsByModel = new Chart(document.getElementById('jobsByModelChart'), {
                type: 'bar',
                data: {
                    labels: Object.keys(jobsByModelData).map(l => l.length > 25 ? l.substring(0, 25) + '...' : l),
                    datasets: [{ label: 'Nº de Pedidos', data: Object.values(jobsByModelData), backgroundColor: chartColors.purple }]
                },
                options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, scales: { x: { beginAtZero: true } } }
            });
        }
        
        function populateSlotFilter() {
            const slotFilter = document.getElementById('slot-filter');
            const currentVal = slotFilter.value;
            slotFilter.innerHTML = '<option value="all">Todos los Slots</option>';
            const slots = [...new Set(processedJobs.map(j => j.Slot_Hour))].sort();
            slots.forEach(slot => {
                if(slot === 'N/A') return;
                const option = document.createElement('option');
                option.value = slot;
                option.textContent = slot;
                slotFilter.appendChild(option);
            });
            slotFilter.value = currentVal;
        }

        function renderTable(jobs) {
            const tableBody = document.getElementById('jobs-table-body');
            const noResults = document.getElementById('no-results');
            tableBody.innerHTML = '';
            
            if (jobs.length === 0) {
                noResults.classList.remove('hidden');
                return;
            }
            
            noResults.classList.add('hidden');
            jobs.forEach(job => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50';
                tr.innerHTML = `
                    <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${job.job_Number || 'N/A'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${job.tienda || 'N/A'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${job.cliente_ID || 'N/A'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${job.Slot_Start_Time || 'N/A'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${job.Slot_End_Time || 'N/A'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${job.metodo_Pago || 'N/A'}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-600">${job.destino?.latitude || 'N/A'}, ${job.destino?.longitude || 'N/A'}</td>
                `;
                tableBody.appendChild(tr);
            });
        }
        
        function logToImportStatus(message, isError = false) {
            const logEl = document.getElementById('import-log');
            logEl.textContent = message;
            logEl.style.color = isError ? '#ef4444' : (message.startsWith('Éxito') ? '#10b981' : '#4b5563');
        }

        // --- LÓGICA DE SINCRONIZACIÓN Y RUTEO (PLANIFICADOR) ---

        function setupRoutingListeners() {
            const genButton = document.getElementById('generate-routes-btn');
            const syncButton = document.getElementById('sync-gheet-btn');
            const exportButton = document.getElementById('export-routes-btn');
            
            syncButton.addEventListener('click', syncFromGoogleSheet);
            genButton.addEventListener('click', triggerVRPGeneration);
            exportButton.addEventListener('click', exportRoutesToCSV);
        }
        
        async function syncFromGoogleSheet() {
            const urlInput = document.getElementById('gheet-url-input');
            const url = urlInput.value;
            
            if (!url || !url.startsWith('https://docs.google.com/spreadsheets/')) {
                logToImportStatus("Error: Por favor, ingrese una URL válida de Google Sheet publicada como CSV.", true);
                return;
            }
            
            logToImportStatus(`Descargando datos desde Google Sheet...`);
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Error al descargar: ${response.statusText}`);
                }
                const csvText = await response.text();
                logToImportStatus(`Datos descargados. Procesando ${csvText.length} bytes...`);
                
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        cleanAndStoreJobs(results.data);
                    },
                    error: (error) => {
                        logToImportStatus(`Error al parsear CSV: ${error.message}`, true);
                    }
                });
                
            } catch (error) {
                logToImportStatus(`Error de red: ${error.message}`, true);
            }
        }

        function cleanAndStoreJobs(jobs) {
            let processedCount = 0;
            let skippedCount = 0;
            allOrders = []; // Limpiar datos anteriores

            logToImportStatus(`Limpiando y preparando ${jobs.length} pedidos...`);

            try {
                for (const job of jobs) {
                    if (!job.Job_Number || !job.Slot_Inicio || !job.Destino_Latitud) {
                        skippedCount++;
                        continue;
                    }
                    
                    const lat = cleanCoordinate(job.Destino_Latitud);
                    const lon = cleanCoordinate(job.Destino_Longitud);
                    const origenLat = cleanCoordinate(job.Origen_Latitud);
                    const origenLon = cleanCoordinate(job.Origen_Longitud);

                    if (isNaN(lat) || isNaN(lon) || isNaN(origenLat) || isNaN(origenLon)) {
                        console.warn("Saltando fila por coordenadas inválidas:", job.Job_Number);
                        skippedCount++;
                        continue;
                    }
                    
                    const fechaCreacion = parseDate(job.Fecha_Creacion);
                    const slotInicio = parseDate(job.Slot_Inicio);
                    const slotFin = parseDate(job.Slot_Fin);
                    const fechaFormalizada = parseDate(job.Fecha_Formalizada);

                    if (!slotInicio || !slotFin || !fechaCreacion) {
                         console.warn("Saltando fila por fechas inválidas:", job.Job_Number);
                         skippedCount++;
                         continue;
                    }
                    
                    // Almacenar en el array local en lugar de Firebase
                    allOrders.push({
                        job_Number: job.Job_Number,
                        status: job.Status || "CREATED",
                        cliente_ID: job.Cliente_ID || null,
                        tienda: job.Tienda || null,
                        fecha_Creacion: fechaCreacion,
                        slot_Inicio: slotInicio,
                        slot_Fin: slotFin,
                        metodo_Pago: job.Metodo_Pago || null,
                        modelo_Operativo: job.Modelo_Operativo || null,
                        origen: { latitude: origenLat, longitude: origenLon },
                        destino: { latitude: lat, longitude: lon },
                        estado: "pendiente", // Estado inicial para el ruteo
                        id_Ruta_Asignada: null,
                        fecha_Formalizada: fechaFormalizada || null
                    });
                    processedCount++;
                }
                
                logToImportStatus(`Éxito: Se cargaron ${processedCount} pedidos en memoria. Se omitieron ${skippedCount} filas inválidas.`, false);
                
                // Actualizar el Dashboard con los nuevos datos
                processAndRenderDashboard();

            } catch (error) {
                console.error("Error al procesar datos:", error);
                logToImportStatus(`Error al procesar: ${error.message}`, true);
            }
        }
        
        async function triggerVRPGeneration() {
            const genButton = document.getElementById('generate-routes-btn');
            const btnText = document.getElementById('btn-text');
            const btnLoader = document.getElementById('btn-loader');
            const exportButton = document.getElementById('export-routes-btn');
            
            genButton.disabled = true;
            exportButton.disabled = true;
            btnText.textContent = 'Generando...';
            btnLoader.classList.remove('hidden');

            const fecha = document.getElementById('vrp-date').value;
            const numVehicles = document.getElementById('vrp-vehicles').value;

            logToImportStatus(`Iniciando simulación de rutas para ${fecha} con ${numVehicles} vehículos...`, false);
            
            try {
                // Simular espera de 1 segundo para la simulación
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const pedidosParaRutear = allOrders.filter(job => {
                    const jobDate = job.fecha_Formalizada || job.fecha_Creacion;
                    if (!jobDate) return false;
                    const jobDateStr = jobDate.toISOString().split('T')[0];
                    return jobDateStr === fecha; // Rutear todos para esa fecha
                });
                
                if (pedidosParaRutear.length === 0) {
                     logToImportStatus(`Simulación finalizada: No hay pedidos para la fecha ${fecha}.`, true);
                     return;
                }

                // Lógica de simulación de VRP (Round-Robin simple)
                const nVehicles = parseInt(numVehicles, 10);
                generatedRoutes = Array.from({ length: nVehicles }, (v, i) => ({ id: `Vehículo ${i + 1}`, orders: [] }));
                unassignedOrders = []; // Por ahora, la simulación simple no deja no asignados

                // Ordenar por slot de inicio para una asignación más lógica
                pedidosParaRutear.sort((a, b) => a.slot_Inicio - b.slot_Inicio);

                pedidosParaRutear.forEach((pedido, index) => {
                    const vehicleIndex = index % nVehicles;
                    generatedRoutes[vehicleIndex].orders.push(pedido);
                });
                
                logToImportStatus(`Simulación local finalizada. Se crearon ${generatedRoutes.filter(r => r.orders.length > 0).length} rutas.`, false);

                // Renderizar los resultados
                renderResults(generatedRoutes, unassignedOrders);
                exportButton.disabled = false; // Activar el botón de exportar

            } catch (error) {
                console.error("Error durante la simulación:", error);
                logToImportStatus(`Error: ${error.message}`, true);
            } finally {
                genButton.disabled = false;
                btnText.textContent = 'Generar Rutas';
                btnLoader.classList.add('hidden');
            }
        }
        
        function renderResults(routes, unassigned) {
            const listEl = document.getElementById('generated-routes-list');
            listEl.innerHTML = '';
            if (routes.length === 0 || routes.every(r => r.orders.length === 0)) {
                listEl.innerHTML = '<p class="text-gray-500">No se generaron rutas.</p>';
            } else {
                routes.forEach(ruta => {
                    if (ruta.orders.length === 0) return; // No mostrar vehículos vacíos
                    
                    const card = document.createElement('div');
                    card.className = 'p-3 border rounded-md bg-gray-50';
                    card.innerHTML = `
                        <h4 class="font-semibold text-indigo-700">${ruta.id}</h4>
                        <p class="text-sm text-gray-600">Pedidos: ${ruta.orders.map(o => o.job_Number).join(', ')}</p>
                        <p class="text-sm text-gray-500">Total: ${ruta.orders.length} entregas</p>
                    `;
                    listEl.appendChild(card);
                });
            }
            
            const unassignedEl = document.getElementById('unassigned-jobs-list');
            unassignedEl.innerHTML = '';
            if (unassigned.length === 0) {
                unassignedEl.innerHTML = '<p class="text-gray-500">No hay pedidos no asignados (en esta simulación).</p>';
            } else {
                unassigned.forEach(pedido => {
                    const item = document.createElement('div');
                    item.className = 'p-2 border-b';
                    item.innerHTML = `
                        <p class="font-medium text-red-600">${pedido.job_Number}</p>
                        <p class="text-sm text-gray-500">Tienda: ${pedido.tienda} / Slot: ${formatDateTime(pedido.slot_Inicio)}</p>
                    `;
                    unassignedEl.appendChild(item);
                });
            }
        }
        
        function exportRoutesToCSV() {
            if (generatedRoutes.length === 0) {
                logToImportStatus("No hay rutas generadas para exportar.", true);
                return;
            }
            
            logToImportStatus("Preparando CSV para exportar...", false);
            const fecha = document.getElementById('vrp-date').value || 'rutas';
            const csvData = [];
            
            // Añadir Encabezado
            csvData.push([
                "Vehiculo_ID", 
                "Job_Number", 
                "Tienda", 
                "Slot_Inicio", 
                "Slot_Fin", 
                "Destino_Lat", 
                "Destino_Lon",
                "Origen_Lat",
                "Origen_Lon"
            ]);

            // Añadir Filas
            generatedRoutes.forEach(route => {
                route.orders.forEach(order => {
                    csvData.push([
                        route.id,
                        order.job_Number,
                        order.tienda,
                        order.Slot_Start_Time, // Usar el tiempo formateado
                        order.Slot_End_Time,   // Usar el tiempo formateado
                        order.destino?.latitude,
                        order.destino?.longitude,
                        order.origen?.latitude,
                        order.origen?.longitude
                    ]);
                });
            });

            // Usar PapaParse para convertir el array a un string CSV
            const csvString = Papa.unparse(csvData);
            
            // Crear y disparar el enlace de descarga
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `rutas_generadas_${fecha}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            logToImportStatus(`Exportación CSV completada para ${fecha}.`, false);
        }

    </script>
</body>
</html>

